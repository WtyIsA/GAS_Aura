---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wutianyi.
--- DateTime: 2025/2/18 16:46
---

require "HashSet"
require "ArrayList"
require "HashMap"
require "Utils"
require("TableEx")

---@class UIWidgetMgr
UIWidgetMgr = {}

local CPP = Global.g_luaMgr
local CacheCount = 30
local UIRoot
local BPRootPath
local ComponentRootPath
local UIIconPath
local UITexturePath
local UICommonPath
local DefaultEmptyImage

local function InitPaths(rootPath)
    UIRoot = rootPath
    BPRootPath = UIRoot .. "UIWidget/"
    ComponentRootPath = UIRoot .. "UIComponent/"
    UIIconPath = UIRoot .. "IconAtlas/"
    UITexturePath = UIRoot
    UICommonPath = "/Game/UI/UI_Common/"
end

local LoadingPanelName = "WBP_Rotating_loading_p"

local NormalLayer = 100
local TopLayer = 500
local NotifyLayer = 600
local LoadingLayer = 800

---@type HashSet<string>
local loadingPanels = HashSet:new()
---@type HashMap<string, UIWidgetBase|UUserWidget>
local prepareSets = HashSet:new()
local loadedPanels = HashMap:new()
local visiblePanels = HashSet:new()
local alwaysShowSets = HashSet:new()
local showStack = ArrayList:new()
local cacheHead
local cacheTail
local waitingCount = {0}
local tmpHashSet = HashSet:new()
local tmpStringTArray = TArray("")

local AllWidgetCanvasParentClass
---@type UUserWidget
local AllWidgetCanvasParent

function UIWidgetMgr.GetWidgetCanvasParent()
    if AllWidgetCanvasParent then
        return AllWidgetCanvasParent
    end
    AllWidgetCanvasParent = CPP:CreateUserWidget(AllWidgetCanvasParentClass)

    CPP:AddUObjectToRoot(AllWidgetCanvasParent)
    CPP:AddWidgetToGameViewPort(AllWidgetCanvasParent,0)
    return AllWidgetCanvasParent
end

local function AddToCache(panel, checkCapacity)
    if not cacheHead then
        cacheHead = panel
        cacheTail = panel
        return
    end

    cacheHead._prev_ = panel
    panel._next_ = cacheHead;
    panel._prev_ = nil
    cacheHead = panel

    if checkCapacity then
        local count = 1
        local current = cacheHead
        local nextOne = current._next_
        while nextOne do
            count = count + 1
            local panelName = nextOne._panelName_
            if count > CacheCount and not visiblePanels:contains(panelName)
                    and not showStack:contains(nextOne) and not nextOne._parent_ and not prepareSets:contains(panelName) then
                loadedPanels:remove(panelName)
                nextOne:DoDestroy()
                current._next_ = nextOne._next_
                nextOne._next_ = nil
                nextOne._prev_ = nil
                nextOne = current._next_
                if nextOne then
                    nextOne._prev_ = current
                end
            else
                current = nextOne
                nextOne = nextOne._next_
            end
        end
    end
end

local function RemoveFromCache(panel)
    local prev = panel._prev_
    local next = panel._next_
    if prev then
        prev._next_ = next
    end
    if next then
        next._prev_ = prev
    end
    panel._prev_ = nil
    panel._next_ = nil

    if cacheTail == panel then
        cacheTail = prev
    end

    if cacheHead == panel then
        cacheHead = next
    end
end

local function UpdateCache(panel)
    if panel == cacheHead then
        return
    end

    RemoveFromCache(panel)
    AddToCache(panel, false)
end

function UIWidgetMgr.Init(uiRootPath, uiLoadingPanelName)
    InitPaths(uiRootPath)
    LoadingPanelName = uiLoadingPanelName
    AllWidgetCanvasParentClass = CPP:LoadRes("/Game/UI/UI_Common/WBP_EmptyCanvas.WBP_EmptyCanvas_C")
    if Global.g_luaMgr.BindWindowEvent then
        Global.g_luaMgr:BindWindowEvent()
    end
    DefaultEmptyImage = CPP:LoadRes("/Game/UI/UI_Common/Texture/Transparent_image.Transparent_image")
end

function UIWidgetMgr.Prepare(panelName, sync)
    if (loadedPanels:contains(panelName) or loadingPanels:contains(panelName)) then
        return
    end
    prepareSets:add(panelName)
    UIWidgetMgr.LoadPanel(not sync, panelName)
end

function UIWidgetMgr.JumpTo(panelName, ...)
    UIWidgetMgr.ShowInternal(panelName, nil, nil,false, true, nil,  true, ...)
end

function UIWidgetMgr.Show(panelName, ...)
    local fromName;
    if showStack:size() > 0 then
        fromName = showStack:get(showStack:size())._panelName_
    end
    UIWidgetMgr.ShowInternal(panelName, nil, fromName,true, true, nil,  false, ...)
end

function UIWidgetMgr.ShowChild(panelName, hidePrev, ...)
    if showStack:size() == 0 then
        print("[UIWidgetMgr.ShowChild]parent not exist")
        return
    end
    local parent = showStack:get(showStack:size())
    UIWidgetMgr.ShowInternal(panelName, nil, parent._panelName_, hidePrev, false, parent, false, ...)
end

function UIWidgetMgr.ShowTop(panelName, ...)
    local TargetLayer = TopLayer
    for k,v in pairs(visiblePanels) do
        local panel = UIWidgetMgr.GetPanel(v)
        if panel then
            local slot = UWidgetLayoutLibrary.SlotAsCanvasSlot(panel.Object)
            if slot then
                if slot.ZOrder < NotifyLayer and slot.ZOrder >= TargetLayer then
                    TargetLayer = slot.ZOrder + 1
                end
            end
        end
    end
    UIWidgetMgr.ShowInternal(panelName, TargetLayer,  nil, false, false, nil,  false, ...)
end

function UIWidgetMgr.ShowNotify(panelName, layer, ...)
    assert(layer > 0 and layer < 100)
    UIWidgetMgr.ShowInternal(panelName, NotifyLayer + layer,  nil, false, false, nil,  false, ...)
end

function UIWidgetMgr.Hide(panelName, notShowPrev)
    if not visiblePanels:contains(panelName) then
        return
    end
    visiblePanels:remove(panelName)

    local panel = loadedPanels:get(panelName)
    if panel then
        UIWidgetMgr.DoHide(panel, nil, notShowPrev)
    end
end

---@deprecated
function UIWidgetMgr.GetPanel(panelName)
    return loadedPanels:get(panelName)
end

function UIWidgetMgr.IsShow(panelName)
    return visiblePanels:contains(panelName)
end

function UIWidgetMgr.IsLoaded(panelName)
    return loadedPanels:contains(panelName)
end

function UIWidgetMgr.HasLoadingPanel()
    return loadingPanels:size() > 0
end

function UIWidgetMgr.HideAll()
    for i = showStack:size(), 1, -1 do
        local panel = showStack:get(i)
        if not alwaysShowSets:contains(panel._panelName_) then
            if visiblePanels:remove(panel._panelName_) then
                UIWidgetMgr.DoHide(panel, nil, true)
            end
        end
    end

    showStack:clear()

    for _, v in pairs(visiblePanels) do
        if not alwaysShowSets:contains(v) then
            UIWidgetMgr.Hide(v)
            visiblePanels:remove(v)
        end
    end
end

function UIWidgetMgr.DestroyAll(retainPanelName)
    UIWidgetMgr.HideAll()
    Utils.LogInfo("UIWidgetMgr","DestroyAll exclude %s", retainPanelName);
    local retainPanel
    for panelName, panel in pairs(loadedPanels) do
        if retainPanelName ~= panelName then
            if not prepareSets:contains(panelName) and not alwaysShowSets:contains(panelName) then
                RemoveFromCache(panel);
                panel:DoDestroy()
                loadedPanels:remove(panelName)
            end
        else
            retainPanel = panel
        end
    end

    --loadedPanels:clear()
    visiblePanels:clear()
    showStack:clear()
    cacheHead = nil
    cacheTail = nil

    if retainPanel then
        loadedPanels:add(retainPanelName,retainPanel)
    end
    visiblePanels:addAll(alwaysShowSets)
end

function UIWidgetMgr.NotWaiting()
    return waitingCount[1] <= 0
end

---@private
function UIWidgetMgr.ShowLoading()
    UIWidgetMgr.ShowInternal(LoadingPanelName, LoadingLayer,  nil, false, false, nil,  false, UIWidgetMgr.NotWaiting)
end

---@private
function UIWidgetMgr.ShowInternal(panelName, layer, fromName, hidePrev, putStack, parent, isJump, ...)
    Utils.LogInfo("UIWidgetMgr","ShowPanel:%s" , panelName)

    if visiblePanels:contains(panelName) then
        return
    end

    visiblePanels:add(panelName)

    local args = {...}
    local panel = loadedPanels:get(panelName)
    if panel ~= nil then
        UIWidgetMgr.PrepareResources(panel, args, function()
            UIWidgetMgr.DoShow(panel, layer, hidePrev, fromName, putStack, parent,  isJump, args)
        end)
        return
    end

    if loadingPanels:contains(panelName) then
        return
    end

    UIWidgetMgr.ShowLoading()

    UIWidgetMgr.LoadPanel(true, panelName, function(newPanel)
        if visiblePanels:contains(panelName) then
            UIWidgetMgr.PrepareResources(newPanel, args, function()
                if visiblePanels:contains(panelName) then
                    if (isJump) then
                        for _, v in pairs(showStack) do
                            UIWidgetMgr.Hide(v._panelName_, true)
                        end
                        showStack:clear()
                    end

                    UIWidgetMgr.DoShow(newPanel, layer, hidePrev, fromName, putStack, parent, isJump, args)
                else
                    UIWidgetMgr.Hide(newPanel._panelName_, true)
                end
            end)
        end
    end)
end

---@private
function UIWidgetMgr.LoadPanel(async, panelName, onLoaded)
    local fullPath = string.format("%s%s.%s_C", BPRootPath, panelName, panelName)
    if async then
        loadingPanels:add(panelName)
        waitingCount[1] = waitingCount[1] + 1
        Utils.LogInfo("UIWidgetMgr", "LoadResAsync Begin:panelName=%s,waitingCount=%d", panelName, waitingCount[1])
        CPP:CreateUserWidgetFromPath(fullPath,true, CppCallback(nil, function(_, _, bpUserWidget)
            waitingCount[1] = waitingCount[1] - 1
            Utils.LogInfo("UIWidgetMgr", "LoadResAsync End:panelName=%s,waitingCount=%d", panelName, waitingCount[1])
            if not bpUserWidget then
                Utils.LogError("UIWidgetMgr", "load panel %s failed", panelName)
                return
            end
            local newPanel = UIWidgetMgr.CreatePanel(panelName, bpUserWidget)
            if onLoaded then
                onLoaded(newPanel)
            end
        end), 0, true)
    else
        local bpUserWidget = CPP:CreateUserWidgetFromPath(fullPath, false)
        local newPanel = UIWidgetMgr.CreatePanel(panelName, bpUserWidget)
        if onLoaded then
            onLoaded(newPanel)
        end

    end
end

---@private
---@param newPanel UUserWidget | UIWidgetBase
function UIWidgetMgr.CreatePanel(panelName, newPanel)
    newPanel._panelName_ = panelName
    loadingPanels:remove(panelName)
    loadedPanels:add(panelName, newPanel)

    if not newPanel._notDestroy_ then
        AddToCache(newPanel, true)
    end

    local panelParent = UIWidgetMgr.GetWidgetCanvasParent()
    if panelParent then
        panelParent.m_parent:AddChildToCanvas(newPanel)
    else
        CPP:AddWidgetToGameViewPort(newPanel, NormalLayer)
    end
    newPanel:SetVisibility(ESlateVisibility.Collapsed)
    Utils.LogInfo("UIWidgetMgr",panelName)
    newPanel:DoInit()
    return newPanel
end

---@private
---@param panel UIWidgetBase
function UIWidgetMgr.PrepareResources(panel, args, onFinished)
    tmpHashSet:clear()
    panel:CallOnCollectResourcesToLoad(tmpHashSet, fromName, args)
    if tmpHashSet:size() > 0 then
        tmpStringTArray:Clear()
        local loaded = panel._loadedResources_
        if not loaded then
            loaded = HashMap:new()
            panel._loadedResources_ = loaded
        end

        local hasNew = false
        for _, v in pairs(tmpHashSet) do
            if not loaded:contains(v) then
                tmpStringTArray:Add(v)
                hasNew = true
            end
        end

        if hasNew then
            UIWidgetMgr.ShowLoading()
            waitingCount[1] = waitingCount[1] + 1
            Utils.LogInfo("UIWidgetMgr", "LoadMultiResAsync Begin:panelName=%s,waitingCount=%d", panel._panelName_, waitingCount[1])
            CPP:LoadMultiResAsync(tmpStringTArray, CppCallback(nil, function(_, resPathArray, resObjectArray)
                waitingCount[1] = waitingCount[1] - 1
                Utils.LogInfo("UIWidgetMgr", "LoadMultiResAsync End:panelName=%s,waitingCount=%d", panel._panelName_, waitingCount[1])
                for i = 1, resPathArray:Length() do
                    local resPath = resPathArray:Get(i)
                    local resObj = resObjectArray:Get(i)
                    if resPath and resObj then
                        panel._loadedResources_:add(resPath, resObj)
                    end
                end
                resPathArray:Release();
                resObjectArray:Release();
                UIWidgetMgr.NotifyResourcesLoaded(panel, args, onFinished)
            end), 0, true)

            tmpStringTArray:Clear()
            return
        end

        tmpHashSet:clear();
    end

    UIWidgetMgr.NotifyResourcesLoaded(panel, args, onFinished)
end

---@private
function UIWidgetMgr.NotifyResourcesLoaded(panel, args, onFinished)
    local waitTime = panel:CallOnResourcesLoaded(panel._loadedResources_, fromName, args)

    if waitTime > 0 then
        UIWidgetMgr.ShowLoading()
        waitingCount[1] = waitingCount[1] + 1
        Utils.LogInfo("UIWidgetMgr", "Delay Begin:panelName=%s,waitingCount=%d", panel._panelName_, waitingCount[1])
        Global.g_Ticker:RegisterTick(UIWidgetMgr,function(_)
            waitingCount[1] = waitingCount[1] - 1
            Utils.LogInfo("UIWidgetMgr", "Delay End:panelName=%s,waitingCount=%d", panel._panelName_, waitingCount[1])
            onFinished()
            return 0
        end,  waitTime * 1000)
    else
        onFinished()
    end
end

---@private
function UIWidgetMgr.DoShow(panel, layer, hidePrev, fromName, putStack, parent, isJump, args)
    visiblePanels:add(panel._panelName_)

    UpdateCache(panel)

    if (isJump) then
        for _, v in pairs(showStack) do
            UIWidgetMgr.Hide(v._panelName_, true)
        end
        showStack:clear()
    end

    if hidePrev then
        local currentPanel = parent
        if not currentPanel then
            currentPanel = panel._parent_
        end
        if currentPanel then
            local siblings = currentPanel._children_
            if siblings and siblings:size() > 0 then
                UIWidgetMgr.DoHide(siblings:get(siblings:size()), panel._panelName_)
            end
        else
            if showStack:size() > 0 then
                UIWidgetMgr.DoHide(showStack:get(showStack:size()), panel._panelName_)
            end
        end
    end

    local zOrder = layer

    if putStack then
        zOrder = NormalLayer
        if showStack:size() > 0 then
            zOrder = showStack:get(showStack:size())._zOrder_ + 20
        end

        showStack:add(panel)
    elseif parent ~= nil then
        zOrder = parent._zOrder_ + 10 + 1
        local children = parent._children_
        if not children then
            children = ArrayList:new()
            parent._children_ = children
        end
        if children:size() > 0 then
            zOrder = children:get(children:size())._zOrder_ + 1
        end
        children:add(panel)
        panel._parent_ = parent
    end

    panel:DoShow(zOrder, fromName, args)

    local children = panel._children_
    if children then
        local visibleChildren = panel._visibleChildren_
        for _, v in pairs(children) do
            if (not visibleChildren) or visibleChildren:contains(v._panelName_) then
                UIWidgetMgr.PrepareResources(v, nil, function()
                    UIWidgetMgr.DoShow(v, nil, false, fromName, false, nil)
                end)
            end
        end
    end
end

---@private
---@param panel UIWidgetBase
function UIWidgetMgr.DoHide(panel, toName, notShowPrev)
    visiblePanels:remove(panel._panelName_)

    local prevToShow;

    if not toName then
        local parent = panel._parent_
        if parent then
            toName = parent._panelName_;
            local siblings = parent._children_
            if siblings then
                siblings:remove(panel)
                panel._parent_ = nil

                if siblings:size() > 0 then
                    prevToShow = siblings:get(siblings:size())
                    toName = prevToShow._panelName_
                end
            end
        else
            showStack:remove(panel)

            if showStack:size() > 0 then
                prevToShow = showStack:get(showStack:size())
                toName = prevToShow._panelName_
            end
        end

        local visibleChildren = panel._visibleChildren_
        if visibleChildren then
            visibleChildren:clear()
        end
    else
        local children = panel._children_
        if children then
            local visibleChildren = panel._visibleChildren_
            if not visibleChildren then
                visibleChildren = HashSet:new()
                panel._visibleChildren_ = visibleChildren
            else
                visibleChildren:clear()
            end

            for _, v in pairs(children) do
                if visiblePanels:contains(v._panelName_) then
                    visibleChildren:add(v._panelName_)
                end
            end
        end
    end

    panel:DoHide(toName)

    local children = panel._children_
    if children then
        for _, v in pairs(children) do
            UIWidgetMgr.DoHide(v, toName)
        end
    end

    if (not notShowPrev) and prevToShow and not visiblePanels:contains(prevToShow._panelName_) then
        UIWidgetMgr.PrepareResources(prevToShow, nil, function()
            UIWidgetMgr.DoShow(prevToShow, nil, false, panel._panelName_, false)
        end)
    end
end

function UIWidgetMgr.GetSpriteFullPath(spritePath)
    local index = Utils.FindLastStrPos(spritePath, "/")
    if not index then
        Utils.LogError("UIWidgetMgr",string.format("[UIWidgetMgr.GetSpriteFullPath]wrong sprite path:%s", spritePath))
        return nil
    end

    local atlasPath = string.sub(spritePath, 1, index)
    local spriteName = string.sub(spritePath, index + 1)
    return string.format("%s%sFrames/%s.%s", UIIconPath, atlasPath, spriteName, spriteName)
end

function UIWidgetMgr.GetTextureFullPath(texturePath)
    local index = Utils.FindLastStrPos(texturePath, "/")
    if not index then
        Utils.LogError("UIWidgetMgr",string.format("[UIWidgetMgr.GetTextFullPath]wrong texture path:%s", texturePath))
        return nil
    end

    local textureName = string.sub(texturePath, index + 1)
    return string.format("%s%s.%s", UITexturePath, texturePath, textureName)
end

function UIWidgetMgr.GetPicFullPath(picPath)
    if string.sub(picPath, 1, 7) == "Texture" then
        return UIWidgetMgr.GetTextureFullPath(picPath)
    else
        return UIWidgetMgr.GetSpriteFullPath(picPath)
    end
end

---@private
function UIWidgetMgr.ErrorHandler(err)
    Utils.LogError("UIWidgetMgr", debug.traceback(err, 2))
end

function UIWidgetMgr.AddWidget(widget,zOder)
    local panelParent = UIWidgetMgr.GetWidgetCanvasParent()
    if panelParent then
        local slot = panelParent.m_parent:AddChildToCanvas(widget);
        if slot then
            local anchors = slot:GetAnchors()
            anchors.Minimum.X = 0
            anchors.Minimum.Y = 0
            anchors.Maximum.X = 1
            anchors.Maximum.Y = 1
            slot:SetAnchors(anchors)
            slot:SetOffsets(FMargin())
            slot:SetZOrder(zOder)
        end
    end
end

function UIWidgetMgr:IsOtherPanelShow(ignorePanelNames)
    for k,v in pairs(visiblePanels) do
        if not ignorePanelNames:contains(v) then
            return false;
        end
    end
    return true;
end

function UIWidgetMgr.GetUIRootPath()
    return UIRoot
end

function UIWidgetMgr.GetUmgWidgetByName(uiName, callback, object, isComponent)
    local strUiName = isComponent and uiName or UIWidgetMgr.GetUiRelativePath(uiName);
    local path = isComponent and ComponentRootPath or BPRootPath
    local loadClassPath = string.format("%s%s.%s_C", path, strUiName, strUiName);
    Global.g_resMgr:AsyncLoad(loadClassPath, UIWidgetMgr, function(_, uClass, _loadClassPath,t)
        local widget = UE4.UWidgetBlueprintLibrary.Create(Global.g_gameInstance:GetWorld(), uClass)
        if callback then
            callback(object, widget)
        end
    end, nil);
end

---@param strName string
function UIWidgetMgr.GetUiRelativePath(strName)
    local strUiName = strName;
    local pos, pos2 = string.find(strName, BPRootPath, 1);
    if(pos == 1)then
        strUiName = string.sub(strName,1, string.len(BPRootPath) - 1);
    else
        if(string.sub(strName, 1,1) == "/")then
            pos = Utils.FindLastStrPos(strName, "/");
            if(pos)then
                strUiName = strName:sub(pos + 1);
            end
        end
    end

    pos , pos2= string.find(strUiName, "%.",1);
    if(pos ~= nil)then
        strUiName = string.sub(strUiName, 1, pos -1 )
    end
    return strUiName;
end

function UIWidgetMgr.GetUICommonPath()
    return UICommonPath
end

function UIWidgetMgr.GetUIComponentPath()
    return ComponentRootPath
end

UIWidgetMgr._YESNO = 1
UIWidgetMgr._OKCANCEL = 2
UIWidgetMgr._OK = 3
---@param message table 提示信息
---@param cbObj table 回调函数的对象
---@param cbOkFun function 点击“OK” “确定”的回调函数
---@param cbCancelFun function 点击 “NO" ”取消“的回调函数 
---@param data any 传递数据，可为空，回调时会返回
function UIWidgetMgr.ShowMessageBox(message, type, cbObj, cbOkFun,cbCancelFun, data , buttonStringId)
    local widpath;
    if(PlatformMgr.nPlatformId == PlatformMgr.PC)then
        widpath = "WBP_MessageBox_p"
    else
        widpath = "WBP_MessageBox_m"
    end
    UIWidgetMgr.ShowNotify(widpath, 15, message, type, cbObj, cbOkFun,cbCancelFun, data , buttonStringId)
end

UIWidgetMgr.AddAlertMessageEvent = "UIWidgetMgr.AddAlertMessageEvent"

---@param message string|table 提示信息
function UIWidgetMgr.ShowAlertBox(message, isIgnore)
    local widpath;
    if not OnlineMgr.IsInBattle then
        UIWidgetMgr.ShowScrollAlertBox(message)
        return
    end
    if(PlatformMgr.nPlatformId == PlatformMgr.PC)then
        widpath = "WBP_AlertBox_p"
        if UIWidgetMgr.IsShow("WBP_BattleLoading") then
            return
        end
    else
        widpath = "WBP_AlertBox_m"
        if UIWidgetMgr.IsShow("WBP_BattleLoading_m") and message ~= Utils.GetString(1037) then
            return
        end
    end
    if(not UIWidgetMgr.IsShow(widpath)) then
        UIWidgetMgr.ShowNotify(widpath, 15, message);
    else
        Global.g_event:TriggerEventMultParam(UIWidgetMgr.AddAlertMessageEvent, message, isIgnore)
    end
end

---@param message string 提示信息
function UIWidgetMgr.ShowScrollAlertBox(message)
    local widpath;
    if(PlatformMgr.nPlatformId == PlatformMgr.PC)then
        widpath = "WBP_ScrollAlertBox_p"
        if UIWidgetMgr.IsShow("WBP_BattleLoading") then
            return
        end
    else
        widpath = "WBP_ScrollAlertBox_m"
        if UIWidgetMgr.IsShow("WBP_BattleLoading_m") then
            return
        end
    end
    if(not UIWidgetMgr.IsShow(widpath))then
        UIWidgetMgr.ShowNotify(widpath, 15, message);
    else
        local widget = UIWidgetMgr.GetPanel(widpath);
        if widget then
            widget:ShowMessage(message);
        else
            UIWidgetMgr.ShowNotify(widpath, 15, message);
        end
    end
end

---@param luawidget UWidget
function UIWidgetMgr.SetUmgControlPosition(luawidget, x,y)
    local translation = luawidget.RenderTransform.Translation;
    translation.X = x
    translation.Y = y
    luawidget:SetRenderTranslation(translation);
end

UIWidgetMgr._ShowGift = 1
UIWidgetMgr._ShowItem = 2
function UIWidgetMgr.ShowRewardReviewPanel(id, type)
    type = type or UIWidgetMgr._ShowGift
    if PlatformMgr.IsPc() then

    else
        UIWidgetMgr.Show("WBP_Reward_review_m", id, type)
    end
end

---@param title table 标题信息
---@param content table 提示信息
---@param moneyTp MoneyType
---@param consume number
---@param cbObj table 回调函数的对象
---@param cbOkFun function 点击“OK” “确定”的回调函数
---@param cbCancelFun function 点击 “NO" ”取消“的回调函数 
---@param data any 传递数据，可为空，回调时会返回
function UIWidgetMgr.ShowMoneyConfirmBox(title, content,moneyTp,consume,cbObj,cbOkFun,cbCancelFun,data)
    local widpath;
    if(PlatformMgr.nPlatformId == PlatformMgr.PC)then
        widpath = "WBP_MoneyConfirmBox_p"
    else
        widpath = "WBP_MoneyConfirmBox_m"
    end
    UIWidgetMgr.ShowNotify(widpath, 13, title, content, moneyTp, consume,cbObj, cbOkFun , cbCancelFun,data)
end

require("HashMap")
---@type HashMap
local m_umgWidge2Lua = HashMap:new();

function UIWidgetMgr.GetLuaWidget(umgWidget)
    local luaW = m_umgWidge2Lua:get(umgWidget);
    return luaW;
end

function UIWidgetMgr.AddLuaWiget(umgWidget,luaWidget)
    m_umgWidge2Lua:add(umgWidget, luaWidget);
end

function UIWidgetMgr.GetDefaultImage()
    if DefaultEmptyImage then
        return DefaultEmptyImage
    end
    DefaultEmptyImage = CPP:LoadRes("/Game/UI/UI_Common/Texture/Transparent_image.Transparent_image")
    return DefaultEmptyImage
end

function UIWidgetMgr.GetRotatingLoadingName()
    return LoadingPanelName
end

return UIWidgetMgr